{"ast":null,"code":"import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'; // worker Saga: will be fired on USER_FETCH_REQUESTED actions\n// function* setData(action) {\n//    try {\n//       const data = yield call(\"setData\", action.payload);\n//       yield put({type: \"USER_FETCH_SUCCEEDED\", data: data});\n//    } catch (e) {\n//       yield put({type: \"USER_FETCH_FAILED\", message: e.message});\n//    }\n// }\n\nfunction* setData(data) {\n  yield put({\n    type: \"setData\",\n    payload: data\n  });\n}\n\nfunction* dataAsync() {\n  yield call(\"callData\", setData);\n}\n/*\r\n  Starts fetchUser on each dispatched `USER_FETCH_REQUESTED` action.\r\n  Allows concurrent fetches of user.\r\n*/\n\n/*\r\n  Alternatively you may use takeLatest.\r\n\r\n  Does not allow concurrent fetches of user. If \"USER_FETCH_REQUESTED\" gets\r\n  dispatched while a fetch is already pending, that pending fetch is cancelled\r\n  and only the latest one will be run.\r\n*/\n\n\nfunction* mySaga() {\n  yield takeLatest(\"USER_FETCH_REQUESTED\", dataAsync);\n}\n\nexport default mySaga;","map":{"version":3,"sources":["C:/Users/hoang/OneDrive/Máy tính/test/interview/src/saga/index.js"],"names":["call","put","takeEvery","takeLatest","setData","data","type","payload","dataAsync","mySaga"],"mappings":"AAAA,SAASA,IAAT,EAAeC,GAAf,EAAoBC,SAApB,EAA+BC,UAA/B,QAAiD,oBAAjD,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAUC,OAAV,CAAmBC,IAAnB,EAAyB;AACvB,QAAMJ,GAAG,CAAC;AAACK,IAAAA,IAAI,EAAE,SAAP;AAAkBC,IAAAA,OAAO,EAAEF;AAA3B,GAAD,CAAT;AACD;;AAED,UAAUG,SAAV,GAAuB;AACrB,QAAMR,IAAI,CAAC,UAAD,EAAaI,OAAb,CAAV;AACD;AAED;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAUK,MAAV,GAAmB;AACjB,QAAMN,UAAU,CAAC,sBAAD,EAAyBK,SAAzB,CAAhB;AACD;;AAED,eAAeC,MAAf","sourcesContent":["import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'\r\n\r\n// worker Saga: will be fired on USER_FETCH_REQUESTED actions\r\n// function* setData(action) {\r\n//    try {\r\n//       const data = yield call(\"setData\", action.payload);\r\n//       yield put({type: \"USER_FETCH_SUCCEEDED\", data: data});\r\n//    } catch (e) {\r\n//       yield put({type: \"USER_FETCH_FAILED\", message: e.message});\r\n//    }\r\n// }\r\n\r\nfunction* setData (data) {\r\n  yield put({type: \"setData\", payload: data});\r\n}\r\n\r\nfunction* dataAsync () {\r\n  yield call(\"callData\", setData);\r\n}\r\n\r\n/*\r\n  Starts fetchUser on each dispatched `USER_FETCH_REQUESTED` action.\r\n  Allows concurrent fetches of user.\r\n*/\r\n\r\n\r\n/*\r\n  Alternatively you may use takeLatest.\r\n\r\n  Does not allow concurrent fetches of user. If \"USER_FETCH_REQUESTED\" gets\r\n  dispatched while a fetch is already pending, that pending fetch is cancelled\r\n  and only the latest one will be run.\r\n*/\r\nfunction* mySaga() {\r\n  yield takeLatest(\"USER_FETCH_REQUESTED\", dataAsync);\r\n}\r\n\r\nexport default mySaga;"]},"metadata":{},"sourceType":"module"}