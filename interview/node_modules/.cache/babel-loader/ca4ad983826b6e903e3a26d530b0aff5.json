{"ast":null,"code":"import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'; // worker Saga: will be fired on USER_FETCH_REQUESTED actions\n\nfunction* setData(action) {\n  try {\n    const data = yield call({\n      type: \"setData\",\n      payload: action.payload\n    });\n    yield put({\n      type: \"USER_FETCH_SUCCEEDED\",\n      data: data\n    });\n  } catch (e) {\n    yield put({\n      type: \"USER_FETCH_FAILED\",\n      message: e.message\n    });\n  }\n}\n/*\r\n  Starts fetchUser on each dispatched `USER_FETCH_REQUESTED` action.\r\n  Allows concurrent fetches of user.\r\n*/\n\n/*\r\n  Alternatively you may use takeLatest.\r\n\r\n  Does not allow concurrent fetches of user. If \"USER_FETCH_REQUESTED\" gets\r\n  dispatched while a fetch is already pending, that pending fetch is cancelled\r\n  and only the latest one will be run.\r\n*/\n\n\nfunction* mySaga() {\n  yield takeLatest(\"USER_FETCH_REQUESTED\", setData);\n}\n\nexport default mySaga;","map":{"version":3,"sources":["C:/Users/hoang/OneDrive/Máy tính/test/interview/src/saga/index.js"],"names":["call","put","takeEvery","takeLatest","setData","action","data","type","payload","e","message","mySaga"],"mappings":"AAAA,SAASA,IAAT,EAAeC,GAAf,EAAoBC,SAApB,EAA+BC,UAA/B,QAAiD,oBAAjD,C,CAEA;;AACA,UAAUC,OAAV,CAAkBC,MAAlB,EAA0B;AACvB,MAAI;AACD,UAAMC,IAAI,GAAG,MAAMN,IAAI,CAAC;AAACO,MAAAA,IAAI,EAAE,SAAP;AAAkBC,MAAAA,OAAO,EAAEH,MAAM,CAACG;AAAlC,KAAD,CAAvB;AACA,UAAMP,GAAG,CAAC;AAACM,MAAAA,IAAI,EAAE,sBAAP;AAA+BD,MAAAA,IAAI,EAAEA;AAArC,KAAD,CAAT;AACF,GAHD,CAGE,OAAOG,CAAP,EAAU;AACT,UAAMR,GAAG,CAAC;AAACM,MAAAA,IAAI,EAAE,mBAAP;AAA4BG,MAAAA,OAAO,EAAED,CAAC,CAACC;AAAvC,KAAD,CAAT;AACF;AACH;AAED;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAUC,MAAV,GAAmB;AACjB,QAAMR,UAAU,CAAC,sBAAD,EAAyBC,OAAzB,CAAhB;AACD;;AAED,eAAeO,MAAf","sourcesContent":["import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'\r\n\r\n// worker Saga: will be fired on USER_FETCH_REQUESTED actions\r\nfunction* setData(action) {\r\n   try {\r\n      const data = yield call({type: \"setData\", payload: action.payload});\r\n      yield put({type: \"USER_FETCH_SUCCEEDED\", data: data});\r\n   } catch (e) {\r\n      yield put({type: \"USER_FETCH_FAILED\", message: e.message});\r\n   }\r\n}\r\n\r\n/*\r\n  Starts fetchUser on each dispatched `USER_FETCH_REQUESTED` action.\r\n  Allows concurrent fetches of user.\r\n*/\r\n\r\n\r\n/*\r\n  Alternatively you may use takeLatest.\r\n\r\n  Does not allow concurrent fetches of user. If \"USER_FETCH_REQUESTED\" gets\r\n  dispatched while a fetch is already pending, that pending fetch is cancelled\r\n  and only the latest one will be run.\r\n*/\r\nfunction* mySaga() {\r\n  yield takeLatest(\"USER_FETCH_REQUESTED\", setData);\r\n}\r\n\r\nexport default mySaga;"]},"metadata":{},"sourceType":"module"}